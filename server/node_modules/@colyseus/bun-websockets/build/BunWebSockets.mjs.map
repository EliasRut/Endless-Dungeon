{
  "version": 3,
  "sources": ["../src/BunWebSockets.ts"],
  "sourcesContent": ["/// <reference types=\"bun-types\" />\nimport Bun, { ServerWebSocket, WebSocketHandler } from \"bun\";\n\nimport http from 'http';\nimport bunExpress from \"bun-serve-express\";\n\nimport { DummyServer, ErrorCode, matchMaker, Transport, debugAndPrintError, spliceOne, ServerError } from '@colyseus/core';\nimport { WebSocketClient, WebSocketWrapper } from './WebSocketClient';\nimport { Application, Request, Response } from \"express\";\n\nexport type TransportOptions = Partial<Omit<WebSocketHandler, \"message\" | \"open\" | \"drain\" | \"close\" | \"ping\" | \"pong\">>;\n\ninterface WebSocketData {\n  url: URL;\n  // query: string,\n  // headers: { [key: string]: string },\n  // connection: { remoteAddress: string },\n}\n\nexport class BunWebSockets extends Transport {\n  public expressApp: Application;\n\n  protected clients: ServerWebSocket<WebSocketData>[] = [];\n  protected clientWrappers = new WeakMap<ServerWebSocket<WebSocketData>, WebSocketWrapper>();\n\n  private _listening: any;\n\n  constructor(private options: TransportOptions = {}) {\n    super();\n\n    const self = this;\n\n    this.expressApp = bunExpress({\n      websocket: {\n        ...this.options,\n\n        async open(ws) {\n          await self.onConnection(ws);\n        },\n\n        message(ws, message) {\n          // this.clientWrappers.get(ws)?.emit('message', Buffer.from(message.slice(0)));\n          self.clientWrappers.get(ws)?.emit('message', message);\n        },\n\n        close(ws, code, reason) {\n          // remove from client list\n          spliceOne(self.clients, self.clients.indexOf(ws));\n\n          const clientWrapper = self.clientWrappers.get(ws);\n          if (clientWrapper) {\n            self.clientWrappers.delete(ws);\n\n            // emit 'close' on wrapper\n            clientWrapper.emit('close', code);\n          }\n        },\n      }\n    });\n\n    // Adding a mock object for Transport.server\n    if (!this.server) {\n      this.server = new DummyServer();\n    }\n  }\n\n  public listen(port: number, hostname?: string, backlog?: number, listeningListener?: () => void) {\n    this._listening = this.expressApp.listen(port, listeningListener);\n\n    this.expressApp.use(`/${matchMaker.controller.matchmakeRoute}`, async (req, res) => {\n      try {\n        await this.handleMatchMakeRequest(req, res);\n      } catch (e) {\n        res.status(500).json({\n          code: e.code,\n          error: e.message\n        });\n      }\n    });\n\n    // Mocking Transport.server behaviour, https://github.com/colyseus/colyseus/issues/458\n    // @ts-ignore\n    this.server.emit(\"listening\");\n\n    return this;\n  }\n\n  public shutdown() {\n    if (this._listening) {\n      this._listening.close();\n\n      // @ts-ignore\n      this.server.emit(\"close\"); // Mocking Transport.server behaviour, https://github.com/colyseus/colyseus/issues/458\n    }\n  }\n\n  public simulateLatency(milliseconds: number) {\n    const originalRawSend = WebSocketClient.prototype.raw;\n    WebSocketClient.prototype.raw = function () {\n      setTimeout(() => originalRawSend.apply(this, arguments), milliseconds);\n    }\n  }\n\n  protected async onConnection(rawClient: ServerWebSocket<WebSocketData>) {\n    const wrapper = new WebSocketWrapper(rawClient);\n    // keep reference to client and its wrapper\n    this.clients.push(rawClient);\n    this.clientWrappers.set(rawClient, wrapper);\n\n    const parsedURL = new URL(rawClient.data.url);\n\n    const sessionId = parsedURL.searchParams.get(\"sessionId\");\n    const processAndRoomId = parsedURL.pathname.match(/\\/[a-zA-Z0-9_\\-]+\\/([a-zA-Z0-9_\\-]+)$/);\n    const roomId = processAndRoomId && processAndRoomId[1];\n\n    const room = matchMaker.getRoomById(roomId);\n    const client = new WebSocketClient(sessionId, wrapper);\n\n    //\n    // TODO: DRY code below with all transports\n    //\n\n    try {\n      if (!room || !room.hasReservedSeat(sessionId, parsedURL.searchParams.get(\"reconnectionToken\") as string)) {\n        throw new Error('seat reservation expired.');\n      }\n\n      await room._onJoin(client, rawClient as unknown as http.IncomingMessage);\n\n    } catch (e) {\n      debugAndPrintError(e);\n\n      // send error code to client then terminate\n      client.error(e.code, e.message, () => rawClient.close());\n    }\n  }\n\n  protected async handleMatchMakeRequest (req: Request, res: Response) {\n    try {\n      switch (req.method) {\n        case 'OPTIONS': {\n          res.set(Object.assign(\n            {},\n            matchMaker.controller.DEFAULT_CORS_HEADERS,\n            matchMaker.controller.getCorsHeaders.call(undefined, req)\n          ));\n          res.status(200).end();\n          break;\n        }\n\n        case 'GET': {\n          const matchedParams = req.path.match(matchMaker.controller.allowedRoomNameChars);\n          const roomName = matchedParams.length > 1 ? matchedParams[matchedParams.length - 1] : \"\";\n          res.json(await matchMaker.controller.getAvailableRooms(roomName || ''));\n          break;\n        }\n\n        case 'POST': {\n          // do not accept matchmaking requests if already shutting down\n          if (matchMaker.isGracefullyShuttingDown) {\n            throw new ServerError(503, \"server is shutting down\");\n          }\n\n          const matchedParams = req.path.match(matchMaker.controller.allowedRoomNameChars);\n          const matchmakeIndex = matchedParams.indexOf(matchMaker.controller.matchmakeRoute);\n          const clientOptions = req.body; // Bun.readableStreamToJSON(req.body);\n\n          if (clientOptions === undefined) {\n            throw new ServerError(500, \"invalid JSON input\");\n          }\n\n          const method = matchedParams[matchmakeIndex + 1];\n          const roomName = matchedParams[matchmakeIndex + 2] || '';\n          res.json(await matchMaker.controller.invokeMethod(method, roomName, clientOptions));\n          break;\n        }\n\n        default: throw new ServerError(500, \"invalid request method\");\n      }\n\n    } catch (e) {\n      res\n        .set(Object.assign(\n          {},\n          matchMaker.controller.DEFAULT_CORS_HEADERS,\n          matchMaker.controller.getCorsHeaders.call(undefined, req)\n        ))\n        .status(500)\n        .json({ code: e.code, error: e.message });\n    }\n\n  }\n\n}\n"],
  "mappings": "AAIA,OAAO,gBAAgB;AAEvB,SAAS,aAAwB,YAAY,WAAW,oBAAoB,WAAW,mBAAmB;AAC1G,SAAS,iBAAiB,wBAAwB;AAY3C,MAAM,sBAAsB,UAAU;AAAA,EAQ3C,YAAoB,UAA4B,CAAC,GAAG;AAClD,UAAM;AADY;AAGlB,UAAM,OAAO;AAEb,SAAK,aAAa,WAAW;AAAA,MAC3B,WAAW;AAAA,QACT,GAAG,KAAK;AAAA,QAER,MAAM,KAAK,IAAI;AACb,gBAAM,KAAK,aAAa,EAAE;AAAA,QAC5B;AAAA,QAEA,QAAQ,IAAI,SAAS;AAEnB,eAAK,eAAe,IAAI,EAAE,GAAG,KAAK,WAAW,OAAO;AAAA,QACtD;AAAA,QAEA,MAAM,IAAI,MAAM,QAAQ;AAEtB,oBAAU,KAAK,SAAS,KAAK,QAAQ,QAAQ,EAAE,CAAC;AAEhD,gBAAM,gBAAgB,KAAK,eAAe,IAAI,EAAE;AAChD,cAAI,eAAe;AACjB,iBAAK,eAAe,OAAO,EAAE;AAG7B,0BAAc,KAAK,SAAS,IAAI;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAGD,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,SAAS,IAAI,YAAY;AAAA,IAChC;AAAA,EACF;AAAA,EA5CO;AAAA,EAEG,UAA4C,CAAC;AAAA,EAC7C,iBAAiB,oBAAI,QAA0D;AAAA,EAEjF;AAAA,EAyCD,OAAO,MAAc,UAAmB,SAAkB,mBAAgC;AAC/F,SAAK,aAAa,KAAK,WAAW,OAAO,MAAM,iBAAiB;AAEhE,SAAK,WAAW,IAAI,IAAI,WAAW,WAAW,kBAAkB,OAAO,KAAK,QAAQ;AAClF,UAAI;AACF,cAAM,KAAK,uBAAuB,KAAK,GAAG;AAAA,MAC5C,SAAS,GAAP;AACA,YAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UACnB,MAAM,EAAE;AAAA,UACR,OAAO,EAAE;AAAA,QACX,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAID,SAAK,OAAO,KAAK,WAAW;AAE5B,WAAO;AAAA,EACT;AAAA,EAEO,WAAW;AAChB,QAAI,KAAK,YAAY;AACnB,WAAK,WAAW,MAAM;AAGtB,WAAK,OAAO,KAAK,OAAO;AAAA,IAC1B;AAAA,EACF;AAAA,EAEO,gBAAgB,cAAsB;AAC3C,UAAM,kBAAkB,gBAAgB,UAAU;AAClD,oBAAgB,UAAU,MAAM,WAAY;AAC1C,iBAAW,MAAM,gBAAgB,MAAM,MAAM,SAAS,GAAG,YAAY;AAAA,IACvE;AAAA,EACF;AAAA,EAEA,MAAgB,aAAa,WAA2C;AACtE,UAAM,UAAU,IAAI,iBAAiB,SAAS;AAE9C,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,eAAe,IAAI,WAAW,OAAO;AAE1C,UAAM,YAAY,IAAI,IAAI,UAAU,KAAK,GAAG;AAE5C,UAAM,YAAY,UAAU,aAAa,IAAI,WAAW;AACxD,UAAM,mBAAmB,UAAU,SAAS,MAAM,uCAAuC;AACzF,UAAM,SAAS,oBAAoB,iBAAiB;AAEpD,UAAM,OAAO,WAAW,YAAY,MAAM;AAC1C,UAAM,SAAS,IAAI,gBAAgB,WAAW,OAAO;AAMrD,QAAI;AACF,UAAI,CAAC,QAAQ,CAAC,KAAK,gBAAgB,WAAW,UAAU,aAAa,IAAI,mBAAmB,CAAW,GAAG;AACxG,cAAM,IAAI,MAAM,2BAA2B;AAAA,MAC7C;AAEA,YAAM,KAAK,QAAQ,QAAQ,SAA4C;AAAA,IAEzE,SAAS,GAAP;AACA,yBAAmB,CAAC;AAGpB,aAAO,MAAM,EAAE,MAAM,EAAE,SAAS,MAAM,UAAU,MAAM,CAAC;AAAA,IACzD;AAAA,EACF;AAAA,EAEA,MAAgB,uBAAwB,KAAc,KAAe;AACnE,QAAI;AACF,cAAQ,IAAI;AAAA,aACL,WAAW;AACd,cAAI,IAAI,OAAO;AAAA,YACb,CAAC;AAAA,YACD,WAAW,WAAW;AAAA,YACtB,WAAW,WAAW,eAAe,KAAK,QAAW,GAAG;AAAA,UAC1D,CAAC;AACD,cAAI,OAAO,GAAG,EAAE,IAAI;AACpB;AAAA,QACF;AAAA,aAEK,OAAO;AACV,gBAAM,gBAAgB,IAAI,KAAK,MAAM,WAAW,WAAW,oBAAoB;AAC/E,gBAAM,WAAW,cAAc,SAAS,IAAI,cAAc,cAAc,SAAS,KAAK;AACtF,cAAI,KAAK,MAAM,WAAW,WAAW,kBAAkB,YAAY,EAAE,CAAC;AACtE;AAAA,QACF;AAAA,aAEK,QAAQ;AAEX,cAAI,WAAW,0BAA0B;AACvC,kBAAM,IAAI,YAAY,KAAK,yBAAyB;AAAA,UACtD;AAEA,gBAAM,gBAAgB,IAAI,KAAK,MAAM,WAAW,WAAW,oBAAoB;AAC/E,gBAAM,iBAAiB,cAAc,QAAQ,WAAW,WAAW,cAAc;AACjF,gBAAM,gBAAgB,IAAI;AAE1B,cAAI,kBAAkB,QAAW;AAC/B,kBAAM,IAAI,YAAY,KAAK,oBAAoB;AAAA,UACjD;AAEA,gBAAM,SAAS,cAAc,iBAAiB;AAC9C,gBAAM,WAAW,cAAc,iBAAiB,MAAM;AACtD,cAAI,KAAK,MAAM,WAAW,WAAW,aAAa,QAAQ,UAAU,aAAa,CAAC;AAClF;AAAA,QACF;AAAA;AAES,gBAAM,IAAI,YAAY,KAAK,wBAAwB;AAAA;AAAA,IAGhE,SAAS,GAAP;AACA,UACG,IAAI,OAAO;AAAA,QACV,CAAC;AAAA,QACD,WAAW,WAAW;AAAA,QACtB,WAAW,WAAW,eAAe,KAAK,QAAW,GAAG;AAAA,MAC1D,CAAC,EACA,OAAO,GAAG,EACV,KAAK,EAAE,MAAM,EAAE,MAAM,OAAO,EAAE,QAAQ,CAAC;AAAA,IAC5C;AAAA,EAEF;AAEF;",
  "names": []
}
