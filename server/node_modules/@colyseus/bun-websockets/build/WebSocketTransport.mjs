import Bun from "bun";
import { DummyServer, ErrorCode, matchMaker, Transport, debugAndPrintError, spliceOne, ServerError } from "@colyseus/core";
import { WebSocketClient, WebSocketWrapper } from "./WebSocketClient";
class uWebSocketsTransport extends Transport {
  constructor(options = {}) {
    super();
    this.options = options;
    if (!this.server) {
      this.server = new DummyServer();
    }
  }
  bunServer;
  clients = [];
  clientWrappers = /* @__PURE__ */ new WeakMap();
  listen(port, hostname, backlog, listeningListener) {
    const handleMatchMakeRequest = this.handleMatchMakeRequest;
    this.bunServer = Bun.serve({
      port,
      hostname,
      async fetch(req, server) {
        const url = new URL(req.url);
        if (url.pathname.startsWith(`/${matchMaker.controller.matchmakeRoute}`)) {
          try {
            const [code, response, headers] = await handleMatchMakeRequest(req, server, url);
            return new Response(response, {
              status: code,
              headers: Object.assign(
                headers,
                matchMaker.controller.DEFAULT_CORS_HEADERS,
                matchMaker.controller.getCorsHeaders.call(void 0, req)
              )
            });
          } catch (e) {
            return new Response(JSON.stringify({ code: e.code, error: e.message }), {
              status: e.code || ErrorCode.MATCHMAKE_UNHANDLED,
              headers: Object.assign(
                { "Content-Type": "application/json" },
                matchMaker.controller.DEFAULT_CORS_HEADERS,
                matchMaker.controller.getCorsHeaders.call(void 0, req)
              )
            });
          }
        } else {
          server.upgrade(req, { data: { url } });
          return void 0;
        }
      },
      websocket: {
        ...this.options,
        async open(ws) {
          await this.onConnection(ws);
        },
        message(ws, message) {
          this.clientWrappers.get(ws)?.emit("message", message);
        },
        close(ws, code, reason) {
          spliceOne(this.clients, this.clients.indexOf(ws));
          const clientWrapper = this.clientWrappers.get(ws);
          if (clientWrapper) {
            this.clientWrappers.delete(ws);
            clientWrapper.emit("close", code);
          }
        }
      }
    });
    listeningListener?.();
    this.server.emit("listening");
    return this;
  }
  shutdown() {
    if (this.bunServer) {
      this.bunServer.stop(true);
      this.server.emit("close");
    }
  }
  simulateLatency(milliseconds) {
    const originalRawSend = WebSocketClient.prototype.raw;
    WebSocketClient.prototype.raw = function() {
      setTimeout(() => originalRawSend.apply(this, arguments), milliseconds);
    };
  }
  async onConnection(rawClient) {
    const wrapper = new WebSocketWrapper(rawClient);
    this.clients.push(rawClient);
    this.clientWrappers.set(rawClient, wrapper);
    const parsedURL = new URL(rawClient.data.url);
    const sessionId = parsedURL.searchParams.get("sessionId");
    const processAndRoomId = parsedURL.pathname.match(/\/[a-zA-Z0-9_\-]+\/([a-zA-Z0-9_\-]+)$/);
    const roomId = processAndRoomId && processAndRoomId[1];
    const room = matchMaker.getRoomById(roomId);
    const client = new WebSocketClient(sessionId, wrapper);
    try {
      if (!room || !room.hasReservedSeat(sessionId, parsedURL.searchParams.get("reconnectionToken"))) {
        throw new Error("seat reservation expired.");
      }
      await room._onJoin(client, rawClient);
    } catch (e) {
      debugAndPrintError(e);
      client.error(e.code, e.message, () => rawClient.close());
    }
  }
  async handleMatchMakeRequest(req, server, url) {
    switch (req.method) {
      case "OPTIONS":
        return [200, void 0, {}];
      case "GET": {
        const matchedParams = url.pathname.match(matchMaker.controller.allowedRoomNameChars);
        const roomName = matchedParams.length > 1 ? matchedParams[matchedParams.length - 1] : "";
        return [
          200,
          JSON.stringify(await matchMaker.controller.getAvailableRooms(roomName || "")),
          {
            "Content-Type": "application/json"
          }
        ];
      }
      case "POST": {
        if (matchMaker.isGracefullyShuttingDown) {
          throw new ServerError(503, "server is shutting down");
        }
        const matchedParams = url.pathname.match(matchMaker.controller.allowedRoomNameChars);
        const matchmakeIndex = matchedParams.indexOf(matchMaker.controller.matchmakeRoute);
        const clientOptions = Bun.readableStreamToJSON(req.body);
        if (clientOptions === void 0) {
          throw new Error("invalid JSON input");
        }
        const method = matchedParams[matchmakeIndex + 1];
        const roomName = matchedParams[matchmakeIndex + 2] || "";
        return [
          200,
          JSON.stringify(await matchMaker.controller.invokeMethod(method, roomName, clientOptions)),
          {
            "Content-Type": "application/json"
          }
        ];
      }
      default:
        return void 0;
    }
  }
}
export {
  uWebSocketsTransport
};
