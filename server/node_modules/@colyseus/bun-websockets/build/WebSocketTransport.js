var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var WebSocketTransport_exports = {};
__export(WebSocketTransport_exports, {
  uWebSocketsTransport: () => uWebSocketsTransport
});
module.exports = __toCommonJS(WebSocketTransport_exports);
var import_bun = __toESM(require("bun"));
var import_core = require("@colyseus/core");
var import_WebSocketClient = require("./WebSocketClient");
class uWebSocketsTransport extends import_core.Transport {
  constructor(options = {}) {
    super();
    this.options = options;
    if (!this.server) {
      this.server = new import_core.DummyServer();
    }
  }
  bunServer;
  clients = [];
  clientWrappers = /* @__PURE__ */ new WeakMap();
  listen(port, hostname, backlog, listeningListener) {
    const handleMatchMakeRequest = this.handleMatchMakeRequest;
    this.bunServer = import_bun.default.serve({
      port,
      hostname,
      async fetch(req, server) {
        const url = new URL(req.url);
        if (url.pathname.startsWith(`/${import_core.matchMaker.controller.matchmakeRoute}`)) {
          try {
            const [code, response, headers] = await handleMatchMakeRequest(req, server, url);
            return new Response(response, {
              status: code,
              headers: Object.assign(
                headers,
                import_core.matchMaker.controller.DEFAULT_CORS_HEADERS,
                import_core.matchMaker.controller.getCorsHeaders.call(void 0, req)
              )
            });
          } catch (e) {
            return new Response(JSON.stringify({ code: e.code, error: e.message }), {
              status: e.code || import_core.ErrorCode.MATCHMAKE_UNHANDLED,
              headers: Object.assign(
                { "Content-Type": "application/json" },
                import_core.matchMaker.controller.DEFAULT_CORS_HEADERS,
                import_core.matchMaker.controller.getCorsHeaders.call(void 0, req)
              )
            });
          }
        } else {
          server.upgrade(req, { data: { url } });
          return void 0;
        }
      },
      websocket: {
        ...this.options,
        async open(ws) {
          await this.onConnection(ws);
        },
        message(ws, message) {
          this.clientWrappers.get(ws)?.emit("message", message);
        },
        close(ws, code, reason) {
          (0, import_core.spliceOne)(this.clients, this.clients.indexOf(ws));
          const clientWrapper = this.clientWrappers.get(ws);
          if (clientWrapper) {
            this.clientWrappers.delete(ws);
            clientWrapper.emit("close", code);
          }
        }
      }
    });
    listeningListener?.();
    this.server.emit("listening");
    return this;
  }
  shutdown() {
    if (this.bunServer) {
      this.bunServer.stop(true);
      this.server.emit("close");
    }
  }
  simulateLatency(milliseconds) {
    const originalRawSend = import_WebSocketClient.WebSocketClient.prototype.raw;
    import_WebSocketClient.WebSocketClient.prototype.raw = function() {
      setTimeout(() => originalRawSend.apply(this, arguments), milliseconds);
    };
  }
  async onConnection(rawClient) {
    const wrapper = new import_WebSocketClient.WebSocketWrapper(rawClient);
    this.clients.push(rawClient);
    this.clientWrappers.set(rawClient, wrapper);
    const parsedURL = new URL(rawClient.data.url);
    const sessionId = parsedURL.searchParams.get("sessionId");
    const processAndRoomId = parsedURL.pathname.match(/\/[a-zA-Z0-9_\-]+\/([a-zA-Z0-9_\-]+)$/);
    const roomId = processAndRoomId && processAndRoomId[1];
    const room = import_core.matchMaker.getRoomById(roomId);
    const client = new import_WebSocketClient.WebSocketClient(sessionId, wrapper);
    try {
      if (!room || !room.hasReservedSeat(sessionId, parsedURL.searchParams.get("reconnectionToken"))) {
        throw new Error("seat reservation expired.");
      }
      await room._onJoin(client, rawClient);
    } catch (e) {
      (0, import_core.debugAndPrintError)(e);
      client.error(e.code, e.message, () => rawClient.close());
    }
  }
  async handleMatchMakeRequest(req, server, url) {
    switch (req.method) {
      case "OPTIONS":
        return [200, void 0, {}];
      case "GET": {
        const matchedParams = url.pathname.match(import_core.matchMaker.controller.allowedRoomNameChars);
        const roomName = matchedParams.length > 1 ? matchedParams[matchedParams.length - 1] : "";
        return [
          200,
          JSON.stringify(await import_core.matchMaker.controller.getAvailableRooms(roomName || "")),
          {
            "Content-Type": "application/json"
          }
        ];
      }
      case "POST": {
        if (import_core.matchMaker.isGracefullyShuttingDown) {
          throw new import_core.ServerError(503, "server is shutting down");
        }
        const matchedParams = url.pathname.match(import_core.matchMaker.controller.allowedRoomNameChars);
        const matchmakeIndex = matchedParams.indexOf(import_core.matchMaker.controller.matchmakeRoute);
        const clientOptions = import_bun.default.readableStreamToJSON(req.body);
        if (clientOptions === void 0) {
          throw new Error("invalid JSON input");
        }
        const method = matchedParams[matchmakeIndex + 1];
        const roomName = matchedParams[matchmakeIndex + 2] || "";
        return [
          200,
          JSON.stringify(await import_core.matchMaker.controller.invokeMethod(method, roomName, clientOptions)),
          {
            "Content-Type": "application/json"
          }
        ];
      }
      default:
        return void 0;
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  uWebSocketsTransport
});
